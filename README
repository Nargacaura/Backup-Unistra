Ce projet utilise les Modèles Numériques de Terrain (ou MNT, https://fr.wikipedia.org/wiki/Mod%C3%A8le_num%C3%A9rique_de_terrain), qui sont simplement des cartes d'altitude d'une région. Elles sont stockées dans des fichiers <*.mnt> de format très simple, en texte clair : quelques caractéristiques (taille, position sur terre, etc.) suivies d'un tableau de nombres flottants donnant l'altitude de chaque point. Quelques exemples, de différentes tailles, se trouvent dans l'archive ci-jointe.

Le code ci-joint consiste à calculer le remplissage des cuvettes de la carte par l'algorithme de Darboux. Le programme fourni enregistre une carte modifiée (cuvettes remplies) dans le fichier passé en troisième argument, ou sur la sortie standard s'il n'y a que deux arguments. Il affiche également sur la sortie standard une carte des cuvettes remplies dans ce cas, en texte clair. La boucle while principale (darboux.c, dernière fonction) calcule itérativement une nouvelle carte W à partir d'une carte existante Wprec, et s'arrête dès que W et Wprec sont identiques. Cette boucle est intrinsèquement séquentielle : W dépend de Wprec à chaque itération. Le calcul de W utilise en chaque point [i,j] la valeur de m[i,j] et les valeurs des 8 voisins de [i,j] dans Wprec : W[i,j] = f(m[i,j], Wprec[i +/- 1, j +/- 1]).

Ce projet consiste à paralléliser l'algorithme de Darboux en MPI (et OpenMP dans l'optimisation). Vous découperez les matrices m, Wprec et W en bandes de tailles égales - ou similaires : la hauteur de la matrice (nrows) n'est pas forcément divisible par le nombre de processus.

Voici quelques indications :
1. Gérez les entrées/sorties sur le processus 0 et distribuez la matrice m dans la fonction mnt_read. A la fin de l'exécution de cette fonction, tous les processus doivent avoir leur (bande de) mnt m allouée et initialisée correctement, ainsi que les valeurs m->ncols, m->nrows, et m->no_data

2. Initialisez la matrice Wprec correctement sur chaque processus au début de la fonction darboux (attention à l'initialisation de la valeur max globale!)

3. Au début de chaque itération de la boucle while principale, vous enverrez les première et/ou dernière ligne de Wprec au processus précédent/suivant (et les recevrez de manière symétrique), car ces processus auront besoin de ces valeurs pour calculer les lignes de leurs bords

4. Puis vient le calcul, chaque processus met à jour sa bande de matrice W

5. Enfin, pour vérifier si le calcul est terminé sur tous les processus, vous ferez une réduction sur la variable modif

6. Récupérez le résultat sur le processus 0 qui gère la sortie.

Une fois que ce programme parallèle fonctionne (il fonctionne s'il calcule exactement les mêmes résultats que le programme séquentiel - vérifiez que c'est le cas !), sauvegardez-le et effectuez des mesures de performance. Puis réfléchissez à son optimisation : les échanges des premières/dernières lignes peuvent être réalisés simultanément à une partie du calcul. De même, la réduction peut être réalisée simultanément au calcul de l'itération suivante, et l'arrêt de la boucle while ne s'effectuera qu'une itération plus tard. Vous pouvez également utiliser OpenMP pour exécuter des boucles parallèles sur chaque processeur multi-coeurs et un seul processus par machine. Mesurez les gains de performances que vous obtenez grâce à ces optimisations. Comparez l'accélération dans le cas simple et dans le cas optimisé. Observez -vous de meilleures performances ?

Est-ce que l'efficacité est de 100% sur quelques machines d'un réseau distribué ?

Ce projet est à réaliser en binôme. Vous déposerez une archive (de préférence .tar.gz) contenant votre code et un petit rapport (format pdf) contenant les mesures que vous avez effectuées. N'oubliez pas d'indiquer les noms des deux participants au projet dans le rapport, et ne déposez qu'une seule archive par binôme. N'incluez pas les fichiers de données fournis (le répertoire MNT/input/), ils sont trop gros pour être déposés sur moodle.
